diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/AgentRegistry.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/AgentRegistry.java
new file mode 100644
index 000000000..1db329977
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/AgentRegistry.java
@@ -0,0 +1,77 @@
+package net.runelite.client.helper.agent;
+
+/**
+ * Registry for agent modules and services.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This registry is part of the hybrid patch-based approach.
+ */
+
+import net.runelite.client.helper.agent.services.*;
+import net.runelite.client.helper.agent.helpermodules.*;
+import java.util.ArrayList;
+import java.util.List;
+import net.runelite.client.helper.agent.services.AgentService;
+import net.runelite.client.helper.agent.helpermodules.AgentModule;
+import net.runelite.client.helper.agent.services.DebugLoggingService;
+import net.runelite.client.helper.agent.helpermodules.dummy.DummyModule;
+import net.runelite.client.helper.agent.listeners.OverlayModuleToggleListener;
+import net.runelite.client.helper.agent.helpermodules.agility.AgilityModule;
+import net.runelite.client.helper.agent.services.AgilityAutomationService;
+import net.runelite.client.helper.agent.services.MenuEntryService;
+import net.runelite.client.helper.agent.services.GameStateService;
+import net.runelite.client.helper.agent.services.HookingService;
+
+public class AgentRegistry {
+    private final List<AgentService> services = new ArrayList<>();
+    private final List<AgentModule> modules = new ArrayList<>();
+    private final OverlayModuleToggleListener moduleToggleListener = new OverlayModuleToggleListener();
+    private final OverlayInjectionService overlayInjectionService = new OverlayInjectionService();
+    private final MenuEntryService menuEntryService = new MenuEntryService();
+    private final HookingService hookingService = new HookingService();
+    private final GameStateService gameStateService = new GameStateService(hookingService);
+    private final AgilityAutomationService agilityAutomationService = new AgilityAutomationService(menuEntryService, gameStateService);
+
+    public AgentRegistry() {
+        // Register core services and modules here
+        services.add(new DebugLoggingService());
+        services.add(overlayInjectionService);
+        services.add(agilityAutomationService);
+        services.add(menuEntryService);
+        services.add(gameStateService);
+        services.add(hookingService);
+        modules.add(new DummyModule());
+        modules.add(new AgilityModule(agilityAutomationService));
+    }
+
+    public List<AgentService> getServices() {
+        return services;
+    }
+
+    public List<AgentModule> getModules() {
+        return modules;
+    }
+
+    public OverlayModuleToggleListener getModuleToggleListener() {
+        return moduleToggleListener;
+    }
+
+    public OverlayInjectionService getOverlayInjectionService() {
+        return overlayInjectionService;
+    }
+
+    public AgilityAutomationService getAgilityAutomationService() {
+        return agilityAutomationService;
+    }
+
+    public MenuEntryService getMenuEntryService() {
+        return menuEntryService;
+    }
+
+    public GameStateService getGameStateService() {
+        return gameStateService;
+    }
+
+    public HookingService getHookingService() {
+        return hookingService;
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/OsrsHelperAgent.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/OsrsHelperAgent.java
new file mode 100644
index 000000000..bc941551c
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/OsrsHelperAgent.java
@@ -0,0 +1,64 @@
+package net.runelite.client.helper.agent;
+
+/**
+ * Main entry point for the OSRS Helper Agent.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This agent is part of the hybrid patch-based approach.
+ */
+
+import java.io.File;
+import java.io.FileWriter;
+import java.io.IOException;
+import java.util.logging.*;
+import com.osrs.helper.agent.overlay.OverlayWindow;
+import com.osrs.helper.agent.listeners.OverlayModuleToggleListener;
+import com.osrs.helper.agent.services.AgentService;
+
+public class OsrsHelperAgent {
+    private static final Logger logger = Logger.getLogger("OsrsHelperAgent");
+    private static FileHandler fileHandler;
+    private static OverlayWindow overlayWindow;
+
+    // Call this from a plugin or main class to initialize the helper agent
+    public static void start() {
+        setupLogging();
+        logger.info("OsrsHelperAgent started via start()");
+        initializeAgent();
+    }
+
+    private static void setupLogging() {
+        try {
+            File logFile = new File("agent-output");
+            if (logFile.exists()) {
+                new FileWriter(logFile, false).close(); // Clear file
+            }
+            fileHandler = new FileHandler("agent-output", false);
+            fileHandler.setFormatter(new SimpleFormatter());
+            logger.addHandler(fileHandler);
+            logger.setUseParentHandlers(true);
+        } catch (IOException e) {
+            System.err.println("Failed to set up logging: " + e.getMessage());
+        }
+    }
+
+    private static void initializeAgent() {
+        AgentRegistry registry = new AgentRegistry();
+        // Initialize all services
+        for (AgentService service : registry.getServices()) {
+            service.initialize();
+        }
+        // Initialize and show the overlay with module controls
+        overlayWindow = new OverlayWindow(registry.getModules(), registry.getModuleToggleListener());
+        java.awt.EventQueue.invokeLater(() -> overlayWindow.showOverlay());
+        logger.info("All services initialized. Modules are disabled by default. Overlay started.");
+    }
+
+    public static void launchOverlay() {
+        logger.info("launchOverlay() called via ASM-injected bytecode");
+        java.awt.EventQueue.invokeLater(() -> {
+            if (overlayWindow != null) {
+                overlayWindow.showOverlay();
+            }
+        });
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/canifis-course-obstacles.md b/runelite-client/src/main/java/net/runelite/client/helper/agent/canifis-course-obstacles.md
new file mode 100644
index 000000000..8af99f6f4
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/canifis-course-obstacles.md
@@ -0,0 +1,27 @@
+# Canifis Rooftop Agility Course Obstacles
+
+This file documents the obstacle order, object IDs, and coordinates (to be filled in) for the Canifis Rooftop Agility Course. This information is useful for automation and reference.
+
+## Obstacle Order and Object IDs
+
+1. Start Tree - `ROOFTOPS_CANIFIS_START_TREE`
+2. Gap 1 - `ROOFTOPS_CANIFIS_JUMP`
+3. Gap 2 - `ROOFTOPS_CANIFIS_JUMP_2`
+4. Gap 3 - `ROOFTOPS_CANIFIS_JUMP_5`
+5. Gap 4 - `ROOFTOPS_CANIFIS_JUMP_3`
+6. Pole Vault - `ROOFTOPS_CANIFIS_POLEVAULT`
+7. Gap 5 - `ROOFTOPS_CANIFIS_JUMP_4`
+8. Leap Down (Finish) - `ROOFTOPS_CANIFIS_LEAPDOWN`
+
+| Step | Obstacle Name      | Object ID                   |
+| ---- | ------------------ | --------------------------- |
+| 1    | Start Tree         | ROOFTOPS_CANIFIS_START_TREE |
+| 2    | Gap 1              | ROOFTOPS_CANIFIS_JUMP       |
+| 3    | Gap 2              | ROOFTOPS_CANIFIS_JUMP_2     |
+| 4    | Gap 3              | ROOFTOPS_CANIFIS_JUMP_5     |
+| 5    | Gap 4              | ROOFTOPS_CANIFIS_JUMP_3     |
+| 6    | Pole Vault         | ROOFTOPS_CANIFIS_POLEVAULT  |
+| 7    | Gap 5              | ROOFTOPS_CANIFIS_JUMP_4     |
+| 8    | Leap Down (Finish) | ROOFTOPS_CANIFIS_LEAPDOWN   |
+
+---
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/AgentModule.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/AgentModule.java
new file mode 100644
index 000000000..2f0d75270
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/AgentModule.java
@@ -0,0 +1,28 @@
+package net.runelite.client.helper.agent.helpermodules;
+
+/**
+ * Base class for all agent helper modules.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. All modules must comply with the hybrid patch-based approach.
+ */
+public interface AgentModule {
+    /**
+     * Called when the module is enabled.
+     */
+    void onEnable();
+
+    /**
+     * Called when the module is disabled.
+     */
+    void onDisable();
+
+    /**
+     * @return the display name of the module
+     */
+    String getName();
+
+    /**
+     * @return true if the module is currently enabled
+     */
+    boolean isEnabled();
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityCourse.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityCourse.java
new file mode 100644
index 000000000..06383afa9
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityCourse.java
@@ -0,0 +1,14 @@
+package net.runelite.client.helper.agent.helpermodules.agility;
+
+/**
+ * Represents an agility course for automation.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This class is part of the hybrid patch-based approach.
+ */
+public interface AgilityCourse {
+    /**
+     * @return the display name of the course
+     */
+    String getName();
+    // Future extensibility: add methods for course-specific logic
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityModule.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityModule.java
new file mode 100644
index 000000000..f4d6d4cce
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityModule.java
@@ -0,0 +1,98 @@
+package net.runelite.client.helper.agent.helpermodules.agility;
+
+import com.osrs.helper.agent.helpermodules.AgentModule;
+import com.osrs.helper.agent.services.AgilityAutomationService;
+
+import java.util.Map;
+import java.util.LinkedHashMap;
+
+/**
+ * Agility helper module for course automation.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This module is part of the hybrid patch-based approach.
+ *
+ * Minimal scaffold for the Agility helper module.
+ * This module will be extended to provide automation and overlays for the Agility skill.
+ */
+public class AgilityModule implements AgentModule {
+    private boolean enabled = false;
+    private final Map<String, AgilityCourse> courses = new LinkedHashMap<>();
+    private AgilityCourse selectedCourse = null;
+    private final AgilityAutomationService automationService;
+
+    public AgilityModule(AgilityAutomationService automationService) {
+        this.automationService = automationService;
+        // Register available courses
+        AgilityCourse canifis = new CanifisCourse();
+        courses.put(canifis.getName(), canifis);
+        // Future: add more courses here
+    }
+
+    @Override
+    public void onEnable() {
+        if (selectedCourse == null) {
+            System.err.println("[AgilityModule] Cannot enable: No course selected!");
+            enabled = false;
+            return;
+        }
+        enabled = true;
+        System.out.println("AgilityModule enabled for course: " + selectedCourse.getName());
+        // Start automation
+        automationService.startAutomation(selectedCourse, getCurrentObstacles());
+    }
+
+    @Override
+    public void onDisable() {
+        enabled = false;
+        System.out.println("AgilityModule disabled");
+        // Stop automation
+        automationService.stopAutomation();
+    }
+
+    @Override
+    public String getName() {
+        return "Agility Helper";
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+
+    public java.util.Set<String> getCourseNames() {
+        return courses.keySet();
+    }
+
+    public void setSelectedCourse(String courseName) {
+        this.selectedCourse = courses.get(courseName);
+    }
+
+    public AgilityCourse getSelectedCourse() {
+        return selectedCourse;
+    }
+
+    /**
+     * Returns the list of obstacles for the currently selected course, or null if none selected.
+     */
+    public java.util.List<AgilityObstacle> getCurrentObstacles() {
+        return selectedCourse != null ? ((selectedCourse instanceof CanifisCourse) ? ((CanifisCourse) selectedCourse).getObstacles() : null) : null;
+    }
+
+    public void setMaxLaps(int maxLaps) {
+        if (automationService != null) {
+            automationService.setMaxLaps(maxLaps);
+        }
+    }
+
+    public void startAutomation() {
+        if (selectedCourse != null && automationService != null) {
+            automationService.startAutomation(selectedCourse, getCurrentObstacles());
+        }
+    }
+
+    public void stopAutomation() {
+        if (automationService != null) {
+            automationService.stopAutomation();
+        }
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityObstacle.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityObstacle.java
new file mode 100644
index 000000000..2384d114c
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/AgilityObstacle.java
@@ -0,0 +1,51 @@
+package net.runelite.client.helper.agent.helpermodules.agility;
+
+import com.osrs.helper.agent.helpermodules.agility.WorldPosition;
+
+/**
+ * Represents an obstacle in an agility course.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This class is part of the hybrid patch-based approach.
+ */
+public class AgilityObstacle {
+    private final String name;
+    private final int objectId;
+    private final String menuAction;
+    private final WorldPosition obstaclePosition;
+    private final WorldPosition expectedPlayerPosition;
+    private final int expectedAnimationId;
+    // Future extensibility: coordinates, actions, etc.
+
+    public AgilityObstacle(String name, int objectId, String menuAction, WorldPosition obstaclePosition, WorldPosition expectedPlayerPosition, int expectedAnimationId) {
+        this.name = name;
+        this.objectId = objectId;
+        this.menuAction = menuAction;
+        this.obstaclePosition = obstaclePosition;
+        this.expectedPlayerPosition = expectedPlayerPosition;
+        this.expectedAnimationId = expectedAnimationId;
+    }
+
+    public String getName() {
+        return name;
+    }
+
+    public int getObjectId() {
+        return objectId;
+    }
+
+    public String getMenuAction() {
+        return menuAction;
+    }
+
+    public WorldPosition getObstaclePosition() {
+        return obstaclePosition;
+    }
+
+    public WorldPosition getExpectedPlayerPosition() {
+        return expectedPlayerPosition;
+    }
+
+    public int getExpectedAnimationId() {
+        return expectedAnimationId;
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/CanifisCourse.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/CanifisCourse.java
new file mode 100644
index 000000000..cfbcc87bd
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/CanifisCourse.java
@@ -0,0 +1,41 @@
+package net.runelite.client.helper.agent.helpermodules.agility;
+
+import java.util.List;
+import java.util.Arrays;
+
+/**
+ * Canifis agility course definition for automation.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This class is part of the hybrid patch-based approach.
+ */
+public class CanifisCourse implements AgilityCourse {
+    // Local object ID constants for Canifis rooftop course obstacles (from RuneLite ObjectID)
+    private static final int ROOFTOPS_CANIFIS_START_TREE = 10819;
+    private static final int ROOFTOPS_CANIFIS_JUMP = 10820;
+    private static final int ROOFTOPS_CANIFIS_JUMP_2 = 10821;
+    private static final int ROOFTOPS_CANIFIS_JUMP_5 = 10828;
+    private static final int ROOFTOPS_CANIFIS_JUMP_3 = 10822;
+    private static final int ROOFTOPS_CANIFIS_POLEVAULT = 10823;
+    private static final int ROOFTOPS_CANIFIS_JUMP_4 = 10829;
+    private static final int ROOFTOPS_CANIFIS_LEAPDOWN = 10831;
+
+    private final List<AgilityObstacle> obstacles = Arrays.asList(
+        new AgilityObstacle("Start Tree", ROOFTOPS_CANIFIS_START_TREE, "Climb", new WorldPosition(3508, 3488, 0), new WorldPosition(3508, 3491, 2), 828),
+        new AgilityObstacle("Gap 1", ROOFTOPS_CANIFIS_JUMP, "Jump", new WorldPosition(3508, 3492, 2), new WorldPosition(3516, 3492, 2), 828),
+        new AgilityObstacle("Gap 2", ROOFTOPS_CANIFIS_JUMP_2, "Jump", new WorldPosition(3516, 3492, 2), new WorldPosition(3523, 3498, 2), 828),
+        new AgilityObstacle("Gap 3", ROOFTOPS_CANIFIS_JUMP_5, "Jump", new WorldPosition(3523, 3498, 2), new WorldPosition(3523, 3507, 2), 828),
+        new AgilityObstacle("Gap 4", ROOFTOPS_CANIFIS_JUMP_3, "Jump", new WorldPosition(3523, 3507, 2), new WorldPosition(3516, 3513, 2), 828),
+        new AgilityObstacle("Pole Vault", ROOFTOPS_CANIFIS_POLEVAULT, "Vault", new WorldPosition(3516, 3513, 2), new WorldPosition(3508, 3513, 2), 11789),
+        new AgilityObstacle("Gap 5", ROOFTOPS_CANIFIS_JUMP_4, "Jump", new WorldPosition(3508, 3513, 2), new WorldPosition(3508, 3505, 2), 828),
+        new AgilityObstacle("Leap Down (Finish)", ROOFTOPS_CANIFIS_LEAPDOWN, "Leap-down", new WorldPosition(3508, 3505, 2), new WorldPosition(3506, 3504, 0), 832)
+    );
+
+    @Override
+    public String getName() {
+        return "Canifis Rooftop";
+    }
+
+    public List<AgilityObstacle> getObstacles() {
+        return obstacles;
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/WorldPosition.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/WorldPosition.java
new file mode 100644
index 000000000..b05331981
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/agility/WorldPosition.java
@@ -0,0 +1,20 @@
+package net.runelite.client.helper.agent.helpermodules.agility;
+
+/**
+ * Represents a world position for agility automation.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This class is part of the hybrid patch-based approach.
+ * Simple value class for world position (x, y, plane).
+ */
+public class WorldPosition {
+    public final int x, y, plane;
+    public WorldPosition(int x, int y, int plane) {
+        this.x = x;
+        this.y = y;
+        this.plane = plane;
+    }
+    @Override
+    public String toString() {
+        return "(" + x + ", " + y + ", " + plane + ")";
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/dummy/DummyModule.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/dummy/DummyModule.java
new file mode 100644
index 000000000..148bc4942
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/helpermodules/dummy/DummyModule.java
@@ -0,0 +1,39 @@
+package net.runelite.client.helper.agent.helpermodules.dummy;
+
+import com.osrs.helper.agent.helpermodules.AgentModule;
+import net.runelite.api.DummyApi;
+
+/**
+ * Dummy helper module for demonstration/testing.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This module is part of the hybrid patch-based approach.
+ */
+public class DummyModule implements AgentModule {
+    private boolean enabled = false;
+
+    @Override
+    public void onEnable() {
+        enabled = true;
+        System.out.println("DummyModule enabled");
+        // Call DummyApi.getTestString() and log the result
+        String result = DummyApi.getTestString();
+        System.out.println("DummyApi.getTestString() result: " + result);
+        // Optionally, log to a file or agent logger if available
+    }
+
+    @Override
+    public void onDisable() {
+        enabled = false;
+        System.out.println("DummyModule disabled");
+    }
+
+    @Override
+    public String getName() {
+        return "Dummy Module";
+    }
+
+    @Override
+    public boolean isEnabled() {
+        return enabled;
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/listeners/ModuleToggleListener.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/listeners/ModuleToggleListener.java
new file mode 100644
index 000000000..ec1cc37bb
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/listeners/ModuleToggleListener.java
@@ -0,0 +1,17 @@
+package net.runelite.client.helper.agent.listeners;
+
+import com.osrs.helper.agent.helpermodules.AgentModule;
+
+/**
+ * Listener for module toggle events.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This listener is part of the hybrid patch-based approach.
+ */
+public interface ModuleToggleListener {
+    /**
+     * Called when a module is toggled in the overlay.
+     * @param module The module being toggled
+     * @param enabled True if the module should be enabled, false if disabled
+     */
+    void onModuleToggled(AgentModule module, boolean enabled);
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/listeners/OverlayModuleToggleListener.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/listeners/OverlayModuleToggleListener.java
new file mode 100644
index 000000000..b31398c87
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/listeners/OverlayModuleToggleListener.java
@@ -0,0 +1,20 @@
+package net.runelite.client.helper.agent.listeners;
+
+import com.osrs.helper.agent.helpermodules.AgentModule;
+
+/**
+ * Listener for overlay module toggle events.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This listener is part of the hybrid patch-based approach.
+ * Handles enabling/disabling modules when toggled from the overlay.
+ */
+public class OverlayModuleToggleListener implements ModuleToggleListener {
+    @Override
+    public void onModuleToggled(AgentModule module, boolean enabled) {
+        if (enabled && !module.isEnabled()) {
+            module.onEnable();
+        } else if (!enabled && module.isEnabled()) {
+            module.onDisable();
+        }
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/overlay/OverlayWindow.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/overlay/OverlayWindow.java
new file mode 100644
index 000000000..cc80bf39a
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/overlay/OverlayWindow.java
@@ -0,0 +1,116 @@
+package net.runelite.client.helper.agent.overlay;
+
+/**
+ * Java Swing overlay window for module control.
+ * <b>IMPORTANT:</b> This overlay is the only component that uses injected hooks/ASM. All other agent logic must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This overlay is part of the hybrid patch-based approach.
+ */
+
+import net.runelite.client.helper.agent.helpermodules.AgentModule;
+import net.runelite.client.helper.agent.helpermodules.agility.AgilityModule;
+import net.runelite.client.helper.agent.listeners.ModuleToggleListener;
+
+import javax.swing.*;
+import java.awt.*;
+import java.awt.event.ItemEvent;
+import java.util.List;
+
+/**
+ * OverlayWindow is a Java Swing overlay for controlling agent modules.
+ * This window allows enabling/disabling modules via checkboxes.
+ */
+public class OverlayWindow extends JFrame {
+    private final List<AgentModule> modules;
+    private final JPanel modulePanel;
+    private final ModuleToggleListener toggleListener;
+    private final JPanel configPanel = new JPanel(new BorderLayout());
+
+    public OverlayWindow(List<AgentModule> modules, ModuleToggleListener toggleListener) {
+        this.modules = modules;
+        this.toggleListener = toggleListener;
+        setTitle("OSRS Helper Agent Overlay");
+        setSize(400, 300);
+        setAlwaysOnTop(true);
+        setDefaultCloseOperation(JFrame.HIDE_ON_CLOSE);
+        setLayout(new BorderLayout());
+
+        modulePanel = new JPanel();
+        modulePanel.setLayout(new BoxLayout(modulePanel, BoxLayout.Y_AXIS));
+        add(new JScrollPane(modulePanel), BorderLayout.CENTER);
+        add(configPanel, BorderLayout.SOUTH);
+
+        populateModuleControls();
+    }
+
+    private void populateModuleControls() {
+        modulePanel.removeAll();
+        ButtonGroup group = new ButtonGroup();
+        for (AgentModule module : modules) {
+            JPanel row = new JPanel(new FlowLayout(FlowLayout.LEFT));
+            JCheckBox checkBox = new JCheckBox(module.getName(), module.isEnabled());
+            checkBox.addItemListener(e -> {
+                boolean shouldEnable = checkBox.isSelected();
+                if (toggleListener != null) {
+                    toggleListener.onModuleToggled(module, shouldEnable);
+                }
+                checkBox.setSelected(module.isEnabled());
+            });
+            row.add(checkBox);
+            JButton configButton = new JButton("Options");
+            configButton.addActionListener(e -> showModuleConfig(module));
+            row.add(configButton);
+            modulePanel.add(row);
+            group.add(checkBox);
+        }
+        modulePanel.revalidate();
+        modulePanel.repaint();
+    }
+
+    private void showModuleConfig(AgentModule module) {
+        configPanel.removeAll();
+        if (module instanceof AgilityModule) {
+            AgilityModule agilityModule = (AgilityModule) module;
+            JPanel panel = new JPanel();
+            panel.setLayout(new BoxLayout(panel, BoxLayout.Y_AXIS));
+            panel.add(new JLabel("Select Rooftop Course:"));
+            JComboBox<String> courseSelector = new JComboBox<>(agilityModule.getCourseNames().toArray(new String[0]));
+            String selected = agilityModule.getSelectedCourse() != null ? agilityModule.getSelectedCourse().getName() : null;
+            courseSelector.setSelectedItem(selected);
+            courseSelector.addActionListener(e -> {
+                String selectedCourse = (String) courseSelector.getSelectedItem();
+                agilityModule.setSelectedCourse(selectedCourse);
+            });
+            panel.add(courseSelector);
+            // --- Agility automation options ---
+            panel.add(new JLabel("Max Laps (0 = infinite):"));
+            JSpinner lapSpinner = new JSpinner(new SpinnerNumberModel(1, 0, 1000, 1));
+            panel.add(lapSpinner);
+            JButton startButton = new JButton("Start Automation");
+            JButton stopButton = new JButton("Stop Automation");
+            startButton.addActionListener(e -> {
+                int maxLaps = (int) lapSpinner.getValue();
+                agilityModule.setMaxLaps(maxLaps == 0 ? -1 : maxLaps);
+                agilityModule.startAutomation();
+            });
+            stopButton.addActionListener(e -> agilityModule.stopAutomation());
+            JPanel buttonPanel = new JPanel(new FlowLayout(FlowLayout.LEFT));
+            buttonPanel.add(startButton);
+            buttonPanel.add(stopButton);
+            panel.add(buttonPanel);
+            configPanel.add(panel, BorderLayout.CENTER);
+        } else {
+            // Fallback: no options available
+            configPanel.add(new JLabel("No options available for this module."), BorderLayout.CENTER);
+        }
+        configPanel.revalidate();
+        configPanel.repaint();
+    }
+
+    public void showOverlay() {
+        setVisible(true);
+    }
+
+    public void hideOverlay() {
+        setVisible(false);
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/AgentService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/AgentService.java
new file mode 100644
index 000000000..5631af975
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/AgentService.java
@@ -0,0 +1,19 @@
+package net.runelite.client.helper.agent.services;
+
+/**
+ * Base interface for all agent services.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. All services must comply with the hybrid patch-based approach.
+ * Services should be stateless or manage their own state.
+ */
+public interface AgentService {
+    /**
+     * Called when the service is initialized by the registry.
+     */
+    void initialize();
+
+    /**
+     * Called when the service is being shut down.
+     */
+    void shutdown();
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/AgilityAutomationService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/AgilityAutomationService.java
new file mode 100644
index 000000000..bb21c7353
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/AgilityAutomationService.java
@@ -0,0 +1,231 @@
+package net.runelite.client.helper.agent.services;
+
+import com.osrs.helper.agent.helpermodules.agility.AgilityCourse;
+import com.osrs.helper.agent.helpermodules.agility.AgilityObstacle;
+import java.util.List;
+import java.util.logging.Logger;
+
+/**
+ * Service for automating agility course actions.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This service is part of the hybrid patch-based approach.
+ *
+ * Service responsible for automating the selected agility course.
+ * This is a scaffold for future extensibility and modularity.
+ */
+public class AgilityAutomationService implements AgentService {
+    private static final Logger logger = Logger.getLogger("AgilityAutomationService");
+    private static final int MAX_RETRIES = 3;
+    private boolean running = false;
+    private final MenuEntryService menuEntryService;
+    private final GameStateService gameStateService;
+    private AgilityCourse currentCourse;
+    private List<AgilityObstacle> currentObstacles;
+    private int currentIndex;
+    private int lapCount = 0;
+    private int maxLaps = 1; // Set to -1 for infinite laps
+    private enum State { IDLE, RUNNING, WAITING, ERROR, PAUSED }
+    private State state = State.IDLE;
+    private int currentRetry = 0;
+
+    public AgilityAutomationService(MenuEntryService menuEntryService, GameStateService gameStateService) {
+        this.menuEntryService = menuEntryService;
+        this.gameStateService = gameStateService;
+    }
+
+    @Override
+    public void initialize() {
+        logger.info("AgilityAutomationService initialized");
+    }
+
+    @Override
+    public void shutdown() {
+        logger.info("AgilityAutomationService shutdown");
+        stopAutomation();
+    }
+
+    public void startAutomation(AgilityCourse course, List<AgilityObstacle> obstacles) {
+        if (course == null || obstacles == null || obstacles.isEmpty()) {
+            logger.warning("Cannot start agility automation: No course or obstacles provided.");
+            return;
+        }
+        this.currentCourse = course;
+        this.currentObstacles = obstacles;
+        this.currentIndex = 0;
+        this.running = true;
+        this.lapCount = 0;
+        this.state = State.RUNNING;
+        this.currentRetry = 0;
+        logger.info("Starting agility automation for course: " + course.getName());
+        stepToNextObstacle();
+    }
+
+    public void stopAutomation() {
+        if (running) {
+            logger.info("Stopping agility automation.");
+            running = false;
+            currentCourse = null;
+            currentObstacles = null;
+            currentIndex = 0;
+            state = State.IDLE;
+        }
+    }
+
+    public boolean isRunning() {
+        return running;
+    }
+
+    private void stepToNextObstacle() {
+        if (!running || currentObstacles == null) {
+            logger.info("Agility automation stopped.");
+            state = State.IDLE;
+            stopAutomation();
+            return;
+        }
+        if (currentIndex >= currentObstacles.size()) {
+            lapCount++;
+            logger.info("Completed lap " + lapCount + ".");
+            if (maxLaps > 0 && lapCount >= maxLaps) {
+                logger.info("Max laps reached. Stopping automation.");
+                state = State.IDLE;
+                stopAutomation();
+                return;
+            }
+            currentIndex = 0;
+            logger.info("Starting next lap.");
+        }
+        state = State.RUNNING;
+        currentRetry = 0;
+        AgilityObstacle obstacle = currentObstacles.get(currentIndex);
+        handleObstacle(obstacle);
+    }
+
+    private void handleObstacle(AgilityObstacle obstacle) {
+        logger.info("Handling obstacle: " + obstacle.getName() + " (" + obstacle.getObjectId() + ")");
+        state = State.WAITING;
+        // Wait for player to be at/near the obstacle
+        if (!waitForPlayerAtPosition(obstacle.getObstaclePosition(), 3, 3000)) {
+            handleRetryOrError("Player not at required position for obstacle: " + obstacle.getName(), obstacle);
+            return;
+        }
+        boolean success = menuEntryService.interactWithMenuEntry(obstacle.getMenuAction(), String.valueOf(obstacle.getObjectId()));
+        if (success) {
+            logger.info("Successfully interacted with obstacle: " + obstacle.getName());
+            if (!waitForPlayerToAnimate(3000)) {
+                handleRetryOrError("Player did not start animating for obstacle: " + obstacle.getName(), obstacle);
+                return;
+            }
+            if (!waitForPlayerToStopAnimating(7000)) {
+                handleRetryOrError("Player did not finish obstacle: " + obstacle.getName(), obstacle);
+                return;
+            }
+            // REQUIRED: Validate player is at expected position and/or animation
+            if (!validatePlayerAfterObstacle(obstacle)) {
+                handleRetryOrError("Player did not reach expected state after obstacle: " + obstacle.getName(), obstacle);
+                return;
+            }
+            currentIndex++;
+            stepToNextObstacle();
+        } else {
+            handleRetryOrError("Failed to interact with obstacle: " + obstacle.getName(), obstacle);
+        }
+    }
+
+    private void handleRetryOrError(String message, AgilityObstacle obstacle) {
+        logger.warning(message + " (retry " + (currentRetry + 1) + "/" + MAX_RETRIES + ")");
+        currentRetry++;
+        if (currentRetry < MAX_RETRIES) {
+            logger.info("Retrying obstacle: " + obstacle.getName());
+            handleObstacle(obstacle);
+        } else {
+            logger.severe("Max retries reached for obstacle: " + obstacle.getName() + ". Aborting automation.");
+            state = State.ERROR;
+            stopAutomation();
+        }
+    }
+
+    private boolean waitForPlayerAtPosition(Object requiredPosition, int tolerance, long timeoutMs) {
+        long start = System.currentTimeMillis();
+        while (System.currentTimeMillis() - start < timeoutMs) {
+            if (!running) return false;
+            Object pos = gameStateService.getPlayerPosition();
+            if (pos instanceof com.osrs.helper.agent.helpermodules.agility.WorldPosition) {
+                com.osrs.helper.agent.helpermodules.agility.WorldPosition wp = (com.osrs.helper.agent.helpermodules.agility.WorldPosition) pos;
+                com.osrs.helper.agent.helpermodules.agility.WorldPosition req = (com.osrs.helper.agent.helpermodules.agility.WorldPosition) requiredPosition;
+                logger.info(String.format("[DEBUG] Player position: x=%d, y=%d, plane=%d | Required: x=%d, y=%d, plane=%d | Tolerance: %d", wp.x, wp.y, wp.plane, req.x, req.y, req.plane, tolerance));
+                boolean withinTolerance = Math.abs(wp.x - req.x) <= tolerance && Math.abs(wp.y - req.y) <= tolerance && wp.plane == req.plane;
+                logger.info("[DEBUG] Position within tolerance: " + withinTolerance);
+                if (withinTolerance) {
+                    return true;
+                }
+            } else {
+                logger.warning("[DEBUG] Player position is not a WorldPosition instance: " + (pos == null ? "null" : pos.getClass().getName()));
+            }
+            try { Thread.sleep(50); } catch (InterruptedException ignored) {}
+        }
+        logger.warning("[DEBUG] Timed out waiting for player at required position.");
+        return false;
+    }
+
+    private boolean validatePlayerAfterObstacle(AgilityObstacle obstacle) {
+        Object pos = gameStateService.getPlayerPosition();
+        boolean atExpectedPos = false;
+        if (pos instanceof com.osrs.helper.agent.helpermodules.agility.WorldPosition) {
+            com.osrs.helper.agent.helpermodules.agility.WorldPosition wp = (com.osrs.helper.agent.helpermodules.agility.WorldPosition) pos;
+            com.osrs.helper.agent.helpermodules.agility.WorldPosition expected = obstacle.getExpectedPlayerPosition();
+            atExpectedPos = (wp.x == expected.x && wp.y == expected.y && wp.plane == expected.plane);
+        }
+        boolean correctAnim = (obstacle.getExpectedAnimationId() == -1) || (gameStateService.isPlayerAnimating() && obstacle.getExpectedAnimationId() == getCurrentAnimationId());
+        return atExpectedPos && correctAnim;
+    }
+
+    private int getCurrentAnimationId() {
+        // Use GameStateService/HookingService to get the current animation ID
+        return gameStateService.getCurrentPlayerAnimationId();
+    }
+
+    /**
+     * Waits for the player to start animating, up to the given timeout (ms).
+     */
+    private boolean waitForPlayerToAnimate(long timeoutMs) {
+        long start = System.currentTimeMillis();
+        while (System.currentTimeMillis() - start < timeoutMs) {
+            if (!running) return false;
+            // Use real-time game state from GameStateService
+            if (gameStateService.isPlayerAnimating()) return true;
+            try { Thread.sleep(50); } catch (InterruptedException ignored) {}
+        }
+        return false;
+    }
+
+    /**
+     * Waits for the player to stop animating, up to the given timeout (ms).
+     */
+    private boolean waitForPlayerToStopAnimating(long timeoutMs) {
+        long start = System.currentTimeMillis();
+        while (System.currentTimeMillis() - start < timeoutMs) {
+            if (!running) return false;
+            if (!gameStateService.isPlayerAnimating()) return true;
+            try { Thread.sleep(50); } catch (InterruptedException ignored) {}
+        }
+        return false;
+    }
+
+    public void setMaxLaps(int maxLaps) {
+        this.maxLaps = maxLaps;
+    }
+
+    public int getLapCount() {
+        return lapCount;
+    }
+
+    public State getState() {
+        return state;
+    }
+
+    private void handleError(String message) {
+        logger.warning(message);
+        // TODO: Add retry logic, user feedback, or abort as needed
+        stopAutomation();
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/DebugLoggingService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/DebugLoggingService.java
new file mode 100644
index 000000000..c1c0ee21c
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/DebugLoggingService.java
@@ -0,0 +1,29 @@
+package net.runelite.client.helper.agent.services;
+
+import java.util.logging.Logger;
+
+/**
+ * Service for debug and error logging for the agent.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This service is part of the hybrid patch-based approach.
+ */
+public class DebugLoggingService implements AgentService {
+    private static final Logger logger = Logger.getLogger("DebugLoggingService");
+    private boolean initialized = false;
+
+    @Override
+    public void initialize() {
+        initialized = true;
+        logger.info("DebugLoggingService initialized");
+    }
+
+    @Override
+    public void shutdown() {
+        logger.info("DebugLoggingService shutdown");
+        initialized = false;
+    }
+
+    public boolean isInitialized() {
+        return initialized;
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/GameStateService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/GameStateService.java
new file mode 100644
index 000000000..f26712d6f
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/GameStateService.java
@@ -0,0 +1,66 @@
+package net.runelite.client.helper.agent.services;
+
+import java.util.logging.Logger;
+
+/**
+ * Service for tracking and interacting with game state via the minimal API.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This service is part of the hybrid patch-based approach.
+ *
+ * No ASM or runtime injection is used here.
+ */
+public class GameStateService implements AgentService {
+    private static final Logger logger = Logger.getLogger("GameStateService");
+    private final HookingService hookingService;
+
+    public GameStateService(HookingService hookingService) {
+        this.hookingService = hookingService;
+    }
+
+    @Override
+    public void initialize() {
+        logger.info("GameStateService initialized");
+        // Register listeners with HookingService to update local state or trigger logic
+        hookingService.addPlayerAnimationListener(isAnimating -> {
+            logger.fine("[GameStateService] Player animation state changed: " + isAnimating);
+            // Optionally, trigger automation or update local cache
+        });
+        hookingService.addPlayerPositionListener(position -> {
+            logger.fine("[GameStateService] Player position changed: " + position);
+            // Optionally, trigger automation or update local cache
+        });
+        hookingService.addObjectPresenceListener(objectId -> {
+            logger.fine("[GameStateService] Object presence changed: " + objectId);
+            // Optionally, trigger automation or update local cache
+        });
+    }
+
+    @Override
+    public void shutdown() {
+        logger.info("GameStateService shutdown");
+        // TODO: Clean up hooks or polling
+    }
+
+    // Returns the player's current position (to be implemented via HookingService)
+    public Object getPlayerPosition() {
+        // Use HookingService to get the player's world position via the minimal API only
+        return hookingService.getCurrentPlayerPosition();
+    }
+
+    // Returns true if the player is currently animating (to be implemented via HookingService)
+    public boolean isPlayerAnimating() {
+        // Use HookingService to check if the player is currently performing an animation via the minimal API only
+        return hookingService.getCurrentPlayerAnimating();
+    }
+
+    // Returns true if the specified object is present in the scene (to be implemented via HookingService)
+    public boolean isObjectPresent(String objectId) {
+        // Use HookingService to check if the object with the given ID is present in the scene
+        return hookingService.isObjectPresentNow(objectId);
+    }
+
+    // Returns the player's current animation ID (delegates to HookingService)
+    public int getCurrentPlayerAnimationId() {
+        return hookingService.getCurrentPlayerAnimationId();
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/HookingService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/HookingService.java
new file mode 100644
index 000000000..528e9349f
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/HookingService.java
@@ -0,0 +1,130 @@
+package net.runelite.client.helper.agent.services;
+
+import java.util.*;
+import java.util.logging.Logger;
+import java.util.function.Consumer;
+
+/**
+ * Service for managing hooks and agent integration.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This service is part of the hybrid patch-based approach.
+ *
+ * No ASM or runtime injection is used here.
+ */
+public class HookingService implements AgentService {
+    private static final Logger logger = Logger.getLogger("HookingService");
+
+    // Example: Listeners for player animation state changes
+    private final List<Consumer<Boolean>> playerAnimationListeners = new ArrayList<>();
+    // Example: Listeners for player position changes
+    private final List<Consumer<Object>> playerPositionListeners = new ArrayList<>();
+    // Example: Listeners for object presence changes
+    private final List<Consumer<String>> objectPresenceListeners = new ArrayList<>();
+
+    private int currentPlayerAnimationId = -1;
+    private static HookingService instance;
+    private boolean currentPlayerAnimating = false;
+    private Object currentPlayerPosition = null;
+    private final Set<String> presentObjects = new HashSet<>();
+
+    public HookingService() {
+        instance = this;
+    }
+
+    public static HookingService getInstance() {
+        return instance;
+    }
+
+    // State update methods (to be called by minimal API, not ASM)
+    public void setPlayerAnimating(boolean isAnimating) {
+        this.currentPlayerAnimating = isAnimating;
+        notifyPlayerAnimationChanged(isAnimating);
+    }
+
+    public void setCurrentPlayerAnimationId(int animationId) {
+        this.currentPlayerAnimationId = animationId;
+    }
+
+    public int getCurrentPlayerAnimationId() {
+        return currentPlayerAnimationId;
+    }
+
+    public void setPlayerPosition(Object position) {
+        logger.info("[DEBUG] setPlayerPosition called with: " + (position == null ? "null" : position.toString() + " (" + (position == null ? "null" : position.getClass().getName()) + ")"));
+        this.currentPlayerPosition = position;
+        notifyPlayerPositionChanged(position);
+    }
+
+    public Object getCurrentPlayerPosition() {
+        logger.info("[DEBUG] getCurrentPlayerPosition returning: " + (currentPlayerPosition == null ? "null" : currentPlayerPosition.toString() + " (" + currentPlayerPosition.getClass().getName() + ")"));
+        return currentPlayerPosition;
+    }
+
+    public void setObjectPresence(String objectId, boolean present) {
+        if (present) {
+            presentObjects.add(objectId);
+        } else {
+            presentObjects.remove(objectId);
+        }
+        notifyObjectPresenceChanged(objectId);
+    }
+
+    // --- Synchronous state queries for services ---
+    public boolean getCurrentPlayerAnimating() {
+        return currentPlayerAnimating;
+    }
+
+    public boolean isObjectPresentNow(String objectId) {
+        return presentObjects.contains(objectId);
+    }
+
+    @Override
+    public void initialize() {
+        logger.info("HookingService initialized");
+        // TODO: Set up listeners for RuneLite client events using only the minimal API exposed by patch files
+    }
+
+    @Override
+    public void shutdown() {
+        logger.info("HookingService shutdown");
+        // TODO: Clean up listeners
+    }
+
+    // Register a listener for player animation state changes
+    public void addPlayerAnimationListener(Consumer<Boolean> listener) {
+        playerAnimationListeners.add(listener);
+    }
+
+    // Register a listener for player position changes
+    public void addPlayerPositionListener(Consumer<Object> listener) {
+        playerPositionListeners.add(listener);
+    }
+
+    // Register a listener for object presence changes
+    public void addObjectPresenceListener(Consumer<String> listener) {
+        objectPresenceListeners.add(listener);
+    }
+
+    // Example: Notify all listeners of a player animation state change
+    public void notifyPlayerAnimationChanged(boolean isAnimating) {
+        for (Consumer<Boolean> listener : playerAnimationListeners) {
+            listener.accept(isAnimating);
+        }
+    }
+
+    // Example: Notify all listeners of a player position change
+    public void notifyPlayerPositionChanged(Object position) {
+        for (Consumer<Object> listener : playerPositionListeners) {
+            listener.accept(position);
+        }
+    }
+
+    // Example: Notify all listeners of an object presence change
+    public void notifyObjectPresenceChanged(String objectId) {
+        for (Consumer<String> listener : objectPresenceListeners) {
+            listener.accept(objectId);
+        }
+    }
+
+    // TODO: Add methods for querying current state, registering additional listeners, etc. All must use the minimal API only.
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/MenuEntryService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/MenuEntryService.java
new file mode 100644
index 000000000..ae087dd88
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/MenuEntryService.java
@@ -0,0 +1,39 @@
+package net.runelite.client.helper.agent.services;
+
+import java.util.logging.Logger;
+
+/**
+ * Service for interacting with menu entries via the minimal API.
+ * <b>IMPORTANT:</b> Only the overlay uses injected hooks/ASM. All other interaction with RuneLite must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This service is part of the hybrid patch-based approach.
+ *
+ * No ASM or runtime injection is used here.
+ */
+public class MenuEntryService implements AgentService {
+    private static final Logger logger = Logger.getLogger("MenuEntryService");
+
+    @Override
+    public void initialize() {
+        logger.info("MenuEntryService initialized");
+        // TODO: Set up hooks or listeners for menu entry events if needed
+    }
+
+    @Override
+    public void shutdown() {
+        logger.info("MenuEntryService shutdown");
+        // TODO: Clean up hooks or listeners if needed
+    }
+
+    /**
+     * Attempt to find and interact with a menu entry matching the given action and target.
+     * <b>NOTE:</b> This must use only the minimal API exposed by patch files, not runtime injection.
+     * @param action The menu action (e.g., "Jump", "Climb")
+     * @param target The menu target (e.g., object name or ID)
+     * @return true if the interaction was successful, false otherwise
+     */
+    public boolean interactWithMenuEntry(String action, String target) {
+        logger.info("Attempting to interact with menu entry: action='" + action + "', target='" + target + "'");
+        // TODO: Use only the minimal API exposed by patch files to access RuneLite's menu entries and perform the interaction
+        return false;
+    }
+}
diff --git a/runelite-client/src/main/java/net/runelite/client/helper/agent/services/OverlayInjectionService.java b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/OverlayInjectionService.java
new file mode 100644
index 000000000..a7ad4fd0d
--- /dev/null
+++ b/runelite-client/src/main/java/net/runelite/client/helper/agent/services/OverlayInjectionService.java
@@ -0,0 +1,97 @@
+package net.runelite.client.helper.agent.services;
+
+import java.lang.instrument.ClassFileTransformer;
+import java.lang.instrument.Instrumentation;
+import java.security.ProtectionDomain;
+import java.util.logging.Logger;
+import org.objectweb.asm.*;
+import org.objectweb.asm.commons.AdviceAdapter;
+import java.io.IOException;
+
+/**
+ * Service for injecting the Java Swing overlay into the RuneLite client.
+ * <b>IMPORTANT:</b> This is the ONLY service that uses injected hooks/ASM. All other agent logic must use the minimal API exposed by patch files only.
+ * Do NOT reference or depend on any code from runelite/ directly. This service is part of the hybrid patch-based approach.
+ *
+ * The ASM injection points must be maintained in patch files and documented in osrs-helper-patches/.
+ */
+public class OverlayInjectionService implements AgentService {
+    private static final Logger logger = Logger.getLogger("OverlayInjectionService");
+    private Instrumentation instrumentation;
+
+    @Override
+    public void initialize() {
+        logger.info("OverlayInjectionService initialized");
+        if (instrumentation == null) {
+            logger.warning("Instrumentation is not set. ASM injection will not proceed.");
+            return;
+        }
+        instrumentation.addTransformer(new ClassFileTransformer() {
+            @Override
+            public byte[] transform(ClassLoader loader, String className, Class<?> classBeingRedefined,
+                                    ProtectionDomain protectionDomain, byte[] classfileBuffer) {
+                if ("net/runelite/client/RuneLite".equals(className)) {
+                    logger.info("RuneLite main class detected. Attempting ASM injection.");
+                    try {
+                        // NOTE: All injected logic must be documented in patch files and use only the minimal API.
+                        return injectOverlayLaunch(classfileBuffer);
+                    } catch (Exception e) {
+                        logger.severe("ASM injection failed: " + e.getMessage());
+                        e.printStackTrace();
+                    }
+                }
+                return null;
+            }
+        }, true);
+    }
+
+    /**
+     * Uses ASM to inject overlay launch logic after clientUI.setVisible(true) in RuneLite.main().
+     * <b>NOTE:</b> This must be kept in sync with the patch files in osrs-helper-patches/.
+     * Do not reference runelite/ code directly.
+     */
+    private byte[] injectOverlayLaunch(byte[] classfileBuffer) throws IOException {
+        ClassReader cr = new ClassReader(classfileBuffer);
+        ClassWriter cw = new ClassWriter(ClassWriter.COMPUTE_FRAMES | ClassWriter.COMPUTE_MAXS);
+        ClassVisitor cv = new ClassVisitor(Opcodes.ASM9, cw) {
+            @Override
+            public MethodVisitor visitMethod(int access, String name, String descriptor, String signature, String[] exceptions) {
+                MethodVisitor mv = super.visitMethod(access, name, descriptor, signature, exceptions);
+                if ("main".equals(name) && "([Ljava/lang/String;)V".equals(descriptor)) {
+                    return new AdviceAdapter(Opcodes.ASM9, mv, access, name, descriptor) {
+                        private boolean injected = false;
+                        @Override
+                        public void visitMethodInsn(int opcode, String owner, String name, String desc, boolean itf) {
+                            super.visitMethodInsn(opcode, owner, name, desc, itf);
+                            // Look for clientUI.setVisible(true)
+                            if (!injected && opcode == Opcodes.INVOKEVIRTUAL && "setVisible".equals(name) && "(Z)V".equals(desc)) {
+                                // Inject: OsrsHelperAgent.launchOverlay();
+                                visitMethodInsn(
+                                    Opcodes.INVOKESTATIC,
+                                    "com/osrs/helper/agent/OsrsHelperAgent",
+                                    "launchOverlay",
+                                    "()V",
+                                    false
+                                );
+                                injected = true;
+                            }
+                        }
+                    };
+                }
+                return mv;
+            }
+        };
+        cr.accept(cv, 0);
+        return cw.toByteArray();
+    }
+
+    @Override
+    public void shutdown() {
+        logger.info("OverlayInjectionService shutdown");
+        // TODO: Clean up any hooks or resources if needed
+    }
+
+    public void setInstrumentation(Instrumentation instrumentation) {
+        this.instrumentation = instrumentation;
+    }
+}
